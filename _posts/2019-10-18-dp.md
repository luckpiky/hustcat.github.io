---
layout: post
title:  动态规划
date: 2019-10-19 0:36:30
categories: 算法
tags: 算法 
excerpt: 算法
---

# 使用动态规划求最小路径
```
#include <stdio.h>

int v1[3][5] = {{1,5,7,6,8},
                {4,7,4,4,9},
                {10,3,2,3,2}};

int v2[3][5] = {0};

int min(int a, int b) 
{
    return a < b ? a : b;
}


/*
 * 给定m行n列的网格，每个格子(i, j)里都一个非负数v[i][j]
 * 求一个从左上角(0, 0)到右下角的路径，每一步只能向下或者向右走一步
 * 使得路径上的格子里的数字之和最小
 * 输出最小数字和
 * 
 * 通过动态规划进行计算
 * f(n,m) = min(f(n, m - 1), f(n - 1, m)) + v[n][m]
 * f(n,m)的前一步，是向上或者向左走，取最小值
 * 特殊情况：
 * 1. f(0,0) = v[0][0]
 * 2. n == 0 或 m == 0， 则只能选择一边
 */
int get_min_by_dp(int n, int m)
{
    if (n == 0 && m == 0) {
        v2[0][0] = v1[0][0];
        return v2[0][0];
    }

    if (n == 0) {
        v2[n][m] = get_min_by_dp(n, m - 1) + v1[n][m];
        return v2[n][m];
    }

    if (m == 0) {
        v2[n][m] = get_min_by_dp(n - 1, m) + v1[n][m];
        return v2[n][m];
    }

    int d1 = get_min_by_dp(n - 1, m);
    int d2 = get_min_by_dp(n, m - 1);

    v2[n][m] = min(d1, d2) + v1[n][m];
    return v2[n][m];
}

int main()
{
    int min = get_min_by_dp(2, 4);

    for (int i = 0; i < 3; i++) {
        for (int j = 0; j < 5 ; j++) {
            printf("%d(%d)\t", v1[i][j], v2[i][j]);
        }

        printf("\n");
    }

    printf("%d\n", min);

    return 0;
}
```

